import React, { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import NotificationItem from '../Components/NotificationItems';
import NotificationDetails from '../Components/NotificationDetails';
import SummaryApi from '../common';
import { toast } from 'react-toastify';
import { FaBell, FaEnvelopeOpen, FaCheckDouble, FaTimesCircle } from 'react-icons/fa';
import { useNavigate } from 'react-router-dom';
import './Notification.css';

const NotificationsPage = () => {
    const [notifications, setNotifications] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const { user } = useSelector((state) => state.user);
    const [filter, setFilter] = useState('all');
    const navigate = useNavigate();
    const [selectedNotification, setSelectedNotification] = useState(null);
    const [isDetailsOpen, setIsDetailsOpen] = useState(false);

    const fetchNotifications = async () => {
        setLoading(true);
        setError('');
        try {
            const [transactionRes, reportRes, marketRes] = await Promise.all([
                fetch(SummaryApi.getTransactionNotifications.url, {
                    method: SummaryApi.getTransactionNotifications.method,
                    credentials: 'include',
                }),
                fetch(SummaryApi.getReportNotifications.url, {
                    method: SummaryApi.getReportNotifications.method,
                    credentials: 'include',
                }),
                fetch(SummaryApi.getMarketNotifications.url, {
                    method: 'GET',
                    credentials: 'include',
                }),
            ]);

            const [transactionData, reportData, marketData] = await Promise.all([
                transactionRes.json(),
                reportRes.json(),
                marketRes.json(),
            ]);

            if (transactionData.success && reportData.success && marketData.success) {
                const transactionNotifications = transactionData.data.filter(n =>
                    ['transaction:debit', 'transaction:credit', 'transaction:payment_completed', 'transaction:withdrawal', 'transaction:rejected'].includes(n.type)
                );

                const allNotifications = [...transactionNotifications, ...reportData.data, ...marketData.data].sort(
                    (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
                );

                setNotifications(allNotifications);
            } else {
                setError(
                    `${transactionData.message || ''} ${reportData.message || ''} ${marketData.message || 'Failed to fetch notifications.'}`
                );
            }
        } catch (err) {
            console.error('[Fetch Notifications Error]', err);
            setError('An unexpected error occurred while fetching notifications.');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (user?._id) fetchNotifications();
    }, [user]);

    const handleMarkAsRead = async (notificationId) => {
        try {
            const response = await fetch(`${SummaryApi.markNotificationAsRead.url}/${notificationId}`, {
                method: SummaryApi.markNotificationAsRead.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev =>
                    prev.map(n => n._id === notificationId ? { ...n, isRead: true, read: 'READ' } : n)
                );
                toast.success(data.message || 'Notification marked as read.');
            } else {
                toast.error(data.message || 'Failed to mark notification as read.');
            }
        } catch (error) {
            console.error('[Mark As Read Error]', error);
            toast.error('Failed to mark notification as read.');
        }
    };

    const handleDeleteNotification = async (notificationId) => {
        try {
            const response = await fetch(`${SummaryApi.deleteNotification.url}/${notificationId}`, {
                method: SummaryApi.deleteNotification.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev => prev.filter(n => n._id !== notificationId));
                toast.success(data.message || 'Notification deleted.');
            } else {
                toast.error(data.message || 'Failed to delete notification.');
            }
        } catch (error) {
            console.error('[Delete Notification Error]', error);
            toast.error('Failed to delete notification.');
        }
    };

    const handleMarkAllAsRead = async () => {
        try {
            const response = await fetch(SummaryApi.markAllNotificationsAsRead.url, {
                method: SummaryApi.markAllNotificationsAsRead.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev => prev.map(n => ({ ...n, isRead: true, read: 'READ' })));
                toast.success(data.message || 'All notifications marked as read.');
            } else {
                toast.error(data.message || 'Failed to mark all as read.');
            }
        } catch (error) {
            console.error('[Mark All As Read Error]', error);
            toast.error('Failed to mark all as read.');
        }
    };

    const handleDeleteAll = async () => {
        try {
            const response = await fetch(SummaryApi.deleteAllNotifications.url, {
                method: SummaryApi.deleteAllNotifications.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications([]);
                toast.success(data.message || 'All notifications deleted.');
            } else {
                toast.error(data.message || 'Failed to delete all.');
            }
        } catch (error) {
            console.error('[Delete All Notifications Error]', error);
            toast.error('Failed to delete all notifications.');
        }
    };

    const handleOpenReportReply = (notification) => {
        navigate(`/chat/${notification.relatedObjectId}`);
        if (!notification.isRead) handleMarkAsRead(notification._id);
    };

    const handleViewDetails = (notification) => {
        setSelectedNotification(notification);
        setIsDetailsOpen(true);
    };

    const handleOpenMarketDetails = (marketId) => {
        const marketNotification = notifications.find(n =>
            n.relatedObjectId === marketId && n.onModel === 'userproduct'
        );
        if (marketNotification) {
            setSelectedNotification(marketNotification);
            setIsDetailsOpen(true);
        }
    };

    const handleViewCreditDetails = (notification) => {
        // You can replace this with actual credit modal, drawer, or page routing logic
        setSelectedNotification(notification);
        setIsDetailsOpen(true);
    };

    const handleCloseDetails = () => {
        setIsDetailsOpen(false);
        setSelectedNotification(null);
    };

    const filteredNotifications = () => {
        if (filter === 'unread') return notifications.filter(n => !n.isRead);
        if (filter === 'read') return notifications.filter(n => n.isRead);
        return notifications;
    };

    const hasUnread = notifications.some(n => !n.isRead);

    if (loading) {
        return (
            <div className="flex justify-center items-center h-60">
                <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-gray-900"></div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                <strong className="font-bold">Error!</strong>
                <span className="block sm:inline">{error}</span>
            </div>
        );
    }

    return (
        <div className="mt-6 bg-gray-100">
            <div className="mx-auto shadow-md rounded-md overflow-hidden bg-white">
                <div className="bg-gray-50 border-b border-gray-200 py-28 flex items-center justify-between">
                       <div className="border-b border-gray-200 flex items-center fixed justify-between p-4 mx-auto w-full bg-white shadow-md z-10">
                    <nav className=" flex space-x-3 w-full px-4 sm:px-6" aria-label="Tabs">
                        {['all', 'unread', 'read'].map(tab => (
                            <button
                                key={tab}
                                onClick={() => setFilter(tab)}
                                className={`${
                                    filter === tab
                                        ? 'border-indigo-500 text-indigo-600'
                                        : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                                } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
                            >
                                {tab === 'all' && <><FaBell className="mr-1 inline-block" /> All</>}
                                {tab === 'unread' && <><FaEnvelopeOpen className="mr-1 inline-block" /> Unread</>}
                                {tab === 'read' && <><FaCheckDouble className="mr-1 inline-block" /> Read</>}
                            </button>
                        ))}
                         <button
                            onClick={handleDeleteAll}
                            className="inline-flex items-center bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded text-sm"
                        >
                           Delete All
                        </button>
                        {hasUnread && (
                            <button
                                onClick={handleMarkAllAsRead}
                                className="inline-flex items-center bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm"
                            >
                                Mark All Read
                            </button>
                        )}
                    </nav>
                </div>
                </div>

             <div>
                <ul className="divide-y divide-gray-200">
                    {filteredNotifications().length > 0 ? (
                        filteredNotifications().map(notification => (
                            <NotificationItem
                                key={notification._id}
                                notification={notification}
                                onMarkAsRead={handleMarkAsRead}
                                onDelete={handleDeleteNotification}
                                onOpenReportReply={handleOpenReportReply}
                                onViewDetails={handleViewDetails}
                                onOpenMarketDetails={handleOpenMarketDetails}
                                onViewCreditDetails={handleViewCreditDetails}
                            />
                        ))
                    ) : (
                        <li className="px-4 py-6 text-gray-500 text-center">No notifications here. 😴</li>
                    )}
                </ul>
             </div>

                
            </div>

            {isDetailsOpen && selectedNotification && (
                <NotificationDetails
                    notification={selectedNotification}
                    onClose={handleCloseDetails}
                />
            )}
        </div>
    );
};

export default NotificationsPage;

.....................................................
//////////////////////////////////////////////////////\





// NotificationsPage.js
import React, { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import NotificationItem from '../Components/NotificationItems';
import NotificationDetails from '../Components/NotificationDetails';
import SummaryApi from '../common';
import { toast } from 'react-toastify';
import { FaBell, FaEnvelopeOpen, FaCheckDouble, FaTimesCircle, FaTrash, FaCheck } from 'react-icons/fa';
import { useNavigate } from 'react-router-dom';
import './Notification.css';

const NotificationsPage = () => {
    const [notifications, setNotifications] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const { user } = useSelector((state) => state.user);
    const [filter, setFilter] = useState('all');
    const navigate = useNavigate();
    const [selectedNotification, setSelectedNotification] = useState(null);
    const [isDetailsOpen, setIsDetailsOpen] = useState(false);
    const [selectedNotifications, setSelectedNotifications] = useState([]);
    const [selectAll, setSelectAll] = useState(false);

    const fetchNotifications = async () => {
        setLoading(true);
        setError('');
        try {
            const [transactionRes, reportRes, marketRes] = await Promise.all([
                fetch(SummaryApi.getTransactionNotifications.url, {
                    method: SummaryApi.getTransactionNotifications.method,
                    credentials: 'include',
                }),
                fetch(SummaryApi.getReportNotifications.url, {
                    method: SummaryApi.getReportNotifications.method,
                    credentials: 'include',
                }),
                fetch(SummaryApi.getMarketNotifications.url, {
                    method: 'GET',
                    credentials: 'include',
                }),
            ]);
            const [transactionData, reportData, marketData] = await Promise.all([
                transactionRes.json(),
                reportRes.json(),
                marketRes.json(),
            ]);
            if (transactionData.success && reportData.success && marketData.success) {
                const transactionNotifications = transactionData.data.filter(n =>
                    ['transaction:debit', 'transaction:credit', 'transaction:payment_completed', 'transaction:withdrawal', 'transaction:rejected'].includes(n.type)
                );
                const allNotifications = [...transactionNotifications, ...reportData.data, ...marketData.data].sort(
                    (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
                );
                setNotifications(allNotifications);
            } else {
                setError(
                    `${transactionData.message || ''} ${reportData.message || ''} ${marketData.message || 'Failed to fetch notifications.'}`
                );
            }
        } catch (err) {
            console.error('[Fetch Notifications Error]', err);
            setError('An unexpected error occurred while fetching notifications.');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (user?._id) fetchNotifications();
    }, [user]);

    const handleMarkAsRead = async (notificationId) => {
        try {
            const response = await fetch(`${SummaryApi.markNotificationAsRead.url}/${notificationId}`, {
                method: SummaryApi.markNotificationAsRead.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev =>
                    prev.map(n => n._id === notificationId ? { ...n, isRead: true, read: 'READ' } : n)
                );
                setSelectedNotifications(prev => prev.filter(id => id !== notificationId));
                toast.success(data.message || 'Notification marked as read.');
            } else {
                toast.error(data.message || 'Failed to mark notification as read.');
            }
        } catch (error) {
            console.error('[Mark As Read Error]', error);
            toast.error('Failed to mark notification as read.');
        }
    };

    const handleDeleteNotification = async (notificationId) => {
        try {
            const response = await fetch(`${SummaryApi.deleteNotification.url}/${notificationId}`, {
                method: SummaryApi.deleteNotification.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev => prev.filter(n => n._id !== notificationId));
                setSelectedNotifications(prev => prev.filter(id => id !== notificationId));
                toast.success(data.message || 'Notification deleted.');
            } else {
                toast.error(data.message || 'Failed to delete notification.');
            }
        } catch (error) {
            console.error('[Delete Notification Error]', error);
            toast.error('Failed to delete notification.');
        }
    };

    const handleMarkAllAsRead = async () => {
        if (selectedNotifications.length === 0) {
            toast.info('No notifications selected to mark as read.');
            return;
        }
        try {
            const response = await fetch(SummaryApi.markAllNotificationsAsRead.url, {
                method: SummaryApi.markAllNotificationsAsRead.method,
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ notificationIds: selectedNotifications }),
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev =>
                    prev.map(n =>
                        selectedNotifications.includes(n._id) ? { ...n, isRead: true, read: 'READ' } : n
                    )
                );
                setSelectedNotifications([]);
                setSelectAll(false);
                toast.success(data.message || 'Selected notifications marked as read.');
            } else {
                toast.error(data.message || 'Failed to mark selected as read.');
            }
        } catch (error) {
            console.error('[Mark All As Read Error]', error);
            toast.error('Failed to mark selected notifications as read.');
        }
    };

    const handleDeleteSelected = async () => {
        if (selectedNotifications.length === 0) {
            toast.info('No notifications selected to delete.');
            return;
        }
        try {
            const response = await fetch(SummaryApi.deleteAllNotifications.url, {
                method: SummaryApi.deleteAllNotifications.method,
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ notificationIds: selectedNotifications }),
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev => prev.filter(n => !selectedNotifications.includes(n._id)));
                setSelectedNotifications([]);
                setSelectAll(false);
                toast.success(data.message || 'Selected notifications deleted.');
            } else {
                toast.error(data.message || 'Failed to delete selected notifications.');
            }
        } catch (error) {
            console.error('[Delete Selected Notifications Error]', error);
            toast.error('Failed to delete selected notifications.');
        }
    };

    const handleMarkAllAsReadVisible = async () => {
        try {
            const response = await fetch(SummaryApi.markAllNotificationsAsRead.url, {
                method: SummaryApi.markAllNotificationsAsRead.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications(prev => prev.map(n => ({ ...n, isRead: true, read: 'READ' })));
                toast.success(data.message || 'All notifications marked as read.');
            } else {
                toast.error(data.message || 'Failed to mark all as read.');
            }
        } catch (error) {
            console.error('[Mark All As Read Error]', error);
            toast.error('Failed to mark all as read.');
        }
    };

    const handleDeleteAllVisible = async () => {
        try {
            const response = await fetch(SummaryApi.deleteAllNotifications.url, {
                method: SummaryApi.deleteAllNotifications.method,
                credentials: 'include',
            });
            const data = await response.json();
            if (data.success) {
                setNotifications([]);
                toast.success(data.message || 'All notifications deleted.');
            } else {
                toast.error(data.message || 'Failed to delete all.');
            }
        } catch (error) {
            console.error('[Delete All Notifications Error]', error);
            toast.error('Failed to delete all notifications.');
        }
    };

    const handleOpenReportReply = (notification) => {
        navigate(`/chat/${notification.relatedObjectId}`);
        if (!notification.isRead) handleMarkAsRead(notification._id);
    };

    const handleViewDetails = (notification) => {
        setSelectedNotification(notification);
        setIsDetailsOpen(true);
    };

    const handleOpenMarketDetails = (marketId) => {
        const marketNotification = notifications.find(n =>
            n.relatedObjectId === marketId && n.onModel === 'userproduct'
        );
        if (marketNotification) {
            setSelectedNotification(marketNotification);
            setIsDetailsOpen(true);
        }
    };

    const handleViewCreditDetails = (notification) => {
        setSelectedNotification(notification);
        setIsDetailsOpen(true);
    };

    const handleCloseDetails = () => {
        setIsDetailsOpen(false);
        setSelectedNotification(null);
    };

    const filteredNotifications = () => {
        if (filter === 'unread') return notifications.filter(n => !n.isRead);
        if (filter === 'read') return notifications.filter(n => n.isRead);
        return notifications;
    };

    const hasUnread = notifications.some(n => !n.isRead);
    const hasSelected = selectedNotifications.length > 0;

    const handleCheckboxChange = (notificationId) => {
        setSelectedNotifications(prev => {
            if (prev.includes(notificationId)) {
                return prev.filter(id => id !== notificationId);
            } else {
                return [...prev, notificationId];
            }
        });
    };

    useEffect(() => {
        setSelectAll(filteredNotifications().length > 0 && selectedNotifications.length === filteredNotifications().length);
    }, [selectedNotifications, filteredNotifications]);

    const handleSelectAllChange = () => {
        if (selectAll) {
            setSelectedNotifications([]);
        } else {
            setSelectedNotifications(filteredNotifications().map(n => n._id));
        }
        setSelectAll(!selectAll);
    };

    if (loading) {
        return (
            <div className="flex justify-center items-center h-60">
                <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-gray-900"></div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                <strong className="font-bold">Error!</strong>
                <span className="block sm:inline">{error}</span>
            </div>
        );
    }

    return (
        <div className="mt-2 py-20 bg-gray-100">
            <div className="mx-auto shadow-md rounded-md overflow-hidden bg-white">
                <div className="sticky top-0 bg-white border-b border-gray-200 py-2 md:py-4 z-10">
                    <div className="px-4 sm:px-6 lg:px-8 flex items-center justify-between">
                        <div className="relative w-full md:w-auto">
                            <label htmlFor="tabs" className="sr-only">Filter notifications</label>
                            <select
                                id="tabs"
                                className="block w-full md:hidden py-2 pl-3 pr-10 border border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                                value={filter}
                                onChange={(e) => setFilter(e.target.value)}
                            >
                                <option value="all">All</option>
                                <option value="unread">Unread</option>
                                <option value="read">Read</option>
                            </select>
                            <nav className="hidden md:flex space-x-4" aria-label="Tabs">
                                {['all', 'unread', 'read'].map(tab => (
                                    <button
                                        key={tab}
                                        onClick={() => setFilter(tab)}
                                        className={`${
                                            filter === tab
                                                ? 'bg-indigo-50 text-indigo-700 border-indigo-500'
                                                : 'text-gray-500 hover:text-gray-700 border-transparent hover:border-gray-300'
                                        } whitespace-nowrap py-2 px-3 border-b-2 font-medium text-sm`}
                                    >
                                        {tab === 'all' && <><FaBell className="mr-1 inline-block" /> All</>}
                                        {tab === 'unread' && <><FaEnvelopeOpen className="mr-1 inline-block" /> Unread</>}
                                        {tab === 'read' && <><FaCheckDouble className="mr-1 inline-block" /> Read</>}
                                    </button>
                                ))}
                            </nav>
                        </div>
                    </div>
                </div>

                {hasSelected && (
                    <div className="bg-gray-50 border-b border-gray-200 py-3 px-4 sm:px-6 flex justify-end space-x-2">
                        <button
                            onClick={handleDeleteSelected}
                            className="inline-flex items-center bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-red-500"
                        >
                            <FaTrash className="mr-2" /> Delete Selected
                        </button>
                        <button
                            onClick={handleMarkAllAsRead}
                            className="inline-flex items-center bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                            <FaCheck className="mr-2" /> Mark Selected Read
                        </button>
                    </div>
                )}

                <ul className="divide-y divide-gray-200">
                    {filteredNotifications().length > 0 ? (
                        filteredNotifications().map(notification => (
                            <li key={notification._id} className="relative px-4 py-6 hover:bg-gray-50 transition duration-150 ease-in-out">
                                <div className="flex items-start justify-between">
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            className="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out"
                                            checked={selectedNotifications.includes(notification._id)}
                                            onChange={() => handleCheckboxChange(notification._id)}
                                        />
                                        <div className="ml-3 flex-grow">
                                            <NotificationItem
                                                notification={notification}
                                                onMarkAsRead={handleMarkAsRead}
                                                onDelete={handleDeleteNotification}
                                                onOpenReportReply={handleOpenReportReply}
                                                onViewDetails={handleViewDetails}
                                                onOpenMarketDetails={handleOpenMarketDetails}
                                                onViewCreditDetails={handleViewCreditDetails}
                                            />
                                        </div>
                                    </div>
                                </div>
                            </li>
                        ))
                    ) : (
                        <li className="px-4 py-6 text-gray-500 text-center">No notifications here. 😴</li>
                    )}
                </ul>

                {filteredNotifications().length > 0 && (
                    <div className="md:hidden bg-gray-50 border-t border-gray-200 py-3 px-4 sm:px-6 flex justify-between items-center">
                        <button
                            onClick={handleDeleteAllVisible}
                            className="inline-flex items-center bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-red-500"
                        >
                            <FaTrash className="mr-2" /> Delete All
                        </button>
                        {hasUnread && (
                            <button
                                onClick={handleMarkAllAsReadVisible}
                                className="inline-flex items-center bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            >
                                <FaCheck className="mr-2" /> Mark All Read
                            </button>
                        )}
                    </div>
                )}
            </div>
            {isDetailsOpen && selectedNotification && (
                <NotificationDetails
                    notification={selectedNotification}
                    onClose={handleCloseDetails}
                />
            )}
        </div>
    );
};
export default NotificationsPage;
