import React, { useState, useRef, useEffect, useCallback } from "react";
import SummaryApi from "../common";
import { MdSend, MdClose, MdAdd } from "react-icons/md";
import uploadImage from "../helpers/uploadImage";
import { format } from "date-fns";
import { useParams, useNavigate } from 'react-router-dom';
import { useSelector } from 'react-redux';

const ReportCard = () => {
    const { reportId } = useParams();
    const navigate = useNavigate();
    const [report, setReport] = useState(null);
    const [isLoadingInitial, setIsLoadingInitial] = useState(true);
    const [isSending, setIsSending] = useState(false);
    const [userReplyText, setUserReplyText] = useState("");
    const [userReplyImage, setUserReplyImage] = useState(null);
    const [uploadingReplyImage, setUploadingReplyImage] = useState(false);
    const chatHistoryRef = useRef(null);
    const pollingIntervalRef = useRef(null);
    const { user } = useSelector((state) => state.user);

    const fetchReport = useCallback(async () => {
        try {
            const response = await fetch(SummaryApi.getReports.url, {
                method: SummaryApi.getReports.method,
                credentials: "include",
            });
            if (!response.ok) throw new Error("Network response was not ok");
            const data = await response.json();
            const foundReport = data.data.find(r => r._id === reportId);
            if (foundReport) {
                setReport(foundReport);
            } else {
                navigate('/report');
            }
        } catch (error) {
            console.error("Error fetching report:", error);
            navigate('/report');
        } finally {
            setIsLoadingInitial(false);
        }
    }, [reportId, navigate]);

    useEffect(() => {
        fetchReport();
        pollingIntervalRef.current = setInterval(fetchReport, 5000);
        return () => clearInterval(pollingIntervalRef.current);
    }, [fetchReport]);

    useEffect(() => {
        if (report && chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [report?.chatHistory]);

    const handleUserReplyTextChange = useCallback((e) => {
        setUserReplyText(e.target.value);
    }, []);

    const handleUserReplyImageUpload = useCallback(async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        setUploadingReplyImage(true);
        try {
            const uploadResponse = await uploadImage(file);
            setUserReplyImage(uploadResponse.url);
        } catch (error) {
            console.error("Error uploading user reply image:", error);
        } finally {
            setUploadingReplyImage(false);
        }
    }, []);

    const handleRemoveUserReplyImage = useCallback(() => {
        setUserReplyImage(null);
    }, []);

    const handleUserReplySubmit = useCallback(async () => {
        if (!userReplyText && !userReplyImage) return;

        setIsSending(true);
        try {
            const response = await fetch(SummaryApi.userReplyReport.url.replace(":id", reportId), {
                method: SummaryApi.userReplyReport.method,
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ userReply: userReplyText, userReplyImage: userReplyImage }),
            });

            const data = await response.json();
            if (data.success) {
                setUserReplyText("");
                setUserReplyImage(null);
                await fetchReport();
            } else {
                console.error("Failed to send your reply.");
            }
        } catch (error) {
            console.error("Error sending your reply:", error);
        } finally {
            setIsSending(false);
        }
    }, [reportId, userReplyText, userReplyImage, fetchReport]);

    const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleUserReplySubmit();
        }
    }, [handleUserReplySubmit]);


    if (isLoadingInitial) {
        return <div className="flex justify-center items-center h-screen">Loading...</div>;
    }

    if (!report) {
        return null;
    }

    return (
        <div className="mt-16 h-screen w-screen bg-gradient-to-r from-gray-50 to-gray-100 z-50 p-4 flex flex-col">
            <div className="flex justify-between items-center mb-4 border-b pb-2">
                <h3 className="text-lg font-semibold">{report.category || "No Category"}</h3>
                {report.autoReply && (
                    <div className="flex flex-col mb-3 p-3 rounded-lg shadow-md bg-blue-50 bg-opacity-80 text-blue-700 self-end text-right">
                        <div className="flex justify-between items-center mb-1">
                            <p className="text-base break-words">{report.autoReply}</p>
                            <p className="ml-2 text-sm font-semibold">Moderator</p>
                        </div>
                        <p className="text-xs text-gray-500 mt-1 text-right">
                            {format(new Date(), "yyyy-MM-dd")}
                        </p>
                    </div>
                )}
                <button onClick={() => navigate('/report')} className="p-2 rounded-full hover:bg-gray-200 transition-colors">
                    <MdClose className="text-xl" />
                </button>
            </div>
            <div ref={chatHistoryRef} className="overflow-y-auto flex-grow p-2 rounded-md mb-2">
                {report.chatHistory && report.chatHistory.map((msg, index) => (
                    <div
                        key={index}
                        className={`flex flex-col mb-3 p-3 rounded-lg shadow-md ${msg.sender === "admin" ? "bg-blue-50 bg-opacity-80 text-blue-700 self-end text-right" : "bg-white bg-opacity-80 text-gray-700 self-start text-left"}`}
                    >
                        <div className="flex justify-between items-center mb-1">
                            <p className="text-base break-words">{msg.message}</p>
                            <div className="flex items-center ml-2">
                                {/* {getUserAvatar(msg.sender === "admin" ? "Moderator" : user?.name)} */}
                                {/* <p className="ml-2 text-sm font-semibold">{msg.sender === "admin" ? "Moderator" : user?.name}</p> */}
                            </div>
                        </div>
                        {msg.image && (
                            <img src={msg.image} alt="Chat Attachment" className="max-w-xs h-auto rounded-lg mt-2" />
                        )}
                        <p className="text-xs text-gray-500 mt-1 text-right">
                            {format(new Date(msg.createdAt), "HH:mm:ss")}
                        </p>
                    </div>
                ))}
               
            </div>
            <div className="border-t pt-3 bg-white bg-opacity-80 rounded-b-lg">
                <div className="relative flex items-center">
                    <textarea
                        className="w-full p-3 border rounded-lg bg-gray-50 h-20 text-gray-700 resize-none pr-16"
                        placeholder="Type your reply..."
                        value={userReplyText}
                        onChange={handleUserReplyTextChange}
                        onKeyDown={handleKeyDown}
                    />
                    <button
                        className="absolute right-3 top-1/2 transform -translate-y-1/2 text-blue-600 hover:text-blue-700"
                        onClick={handleUserReplySubmit}
                        disabled={isSending || uploadingReplyImage || (!userReplyText && !userReplyImage)}
                    >
                        <MdSend className="text-2xl" />
                    </button>
                    <label className="absolute right-16 top-1/2 transform -translate-y-1/2 cursor-pointer text-gray-500 hover:text-gray-600">
                        <input type="file" className="hidden" onChange={handleUserReplyImageUpload} />
                        <MdAdd className="text-2xl" />
                    </label>
                </div>
                {userReplyImage && (
                    <div className="relative mt-2">
                        <img src={userReplyImage} alt="Your Reply" className="w-20 h-20 object-cover rounded-lg border" />
                        <button className="absolute top-0 right-0 p-1 bg-red-600 text-white rounded-full" onClick={handleRemoveUserReplyImage}>
                            <MdClose />
                        </button>
                    </div>
                )}
                {uploadingReplyImage && <p className="text-gray-500 text-sm mt-1">Uploading image...</p>}
            </div>
        </div>
    );
};

export default ReportCard;

//

import React, { useState, useRef, useEffect, useCallback } from "react";
import SummaryApi from "../common";
import { MdSend, MdClose, MdAdd } from "react-icons/md";
import uploadImage from "../helpers/uploadImage";
import { format } from "date-fns";
import { useParams, useNavigate } from 'react-router-dom';
import { useSelector } from 'react-redux';
import './ChatInterface.css'; // Import the new CSS file

const ReportCard = () => {
    const { reportId } = useParams();
    const navigate = useNavigate();
    const [report, setReport] = useState(null);
    const [isLoadingInitial, setIsLoadingInitial] = useState(true);
    const [isSending, setIsSending] = useState(false);
    const [userReplyText, setUserReplyText] = useState("");
    const [userReplyImage, setUserReplyImage] = useState(null);
    const [uploadingReplyImage, setUploadingReplyImage] = useState(false);
    const chatHistoryRef = useRef(null);
    const pollingIntervalRef = useRef(null);
    const { user } = useSelector((state) => state.user);

    const fetchReport = useCallback(async () => {
        try {
            const response = await fetch(SummaryApi.getReports.url, {
                method: SummaryApi.getReports.method,
                credentials: "include",
            });
            if (!response.ok) throw new Error("Network response was not ok");
            const data = await response.json();
            const foundReport = data.data.find(r => r._id === reportId);
            if (foundReport) {
                setReport(foundReport);
            } else {
                navigate('/report');
            }
        } catch (error) {
            console.error("Error fetching report:", error);
            navigate('/report');
        } finally {
            setIsLoadingInitial(false);
        }
    }, [reportId, navigate]);

    useEffect(() => {
        fetchReport();
        pollingIntervalRef.current = setInterval(fetchReport, 5000);
        return () => clearInterval(pollingIntervalRef.current);
    }, [fetchReport]);

    useEffect(() => {
        if (report && chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [report?.chatHistory]);

    const handleUserReplyTextChange = useCallback((e) => {
        setUserReplyText(e.target.value);
    }, []);

    const handleUserReplyImageUpload = useCallback(async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        setUploadingReplyImage(true);
        try {
            const uploadResponse = await uploadImage(file);
            setUserReplyImage(uploadResponse.url);
        } catch (error) {
            console.error("Error uploading user reply image:", error);
        } finally {
            setUploadingReplyImage(false);
        }
    }, []);

    const handleRemoveUserReplyImage = useCallback(() => {
        setUserReplyImage(null);
    }, []);

    const handleUserReplySubmit = useCallback(async () => {
        if (!userReplyText && !userReplyImage) return;

        setIsSending(true);
        try {
            const response = await fetch(SummaryApi.userReplyReport.url.replace(":id", reportId), {
                method: SummaryApi.userReplyReport.method,
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ userReply: userReplyText, userReplyImage: userReplyImage }),
            });

            const data = await response.json();
            if (data.success) {
                setUserReplyText("");
                setUserReplyImage(null);
                await fetchReport();
            } else {
                console.error("Failed to send your reply.");
            }
        } catch (error) {
            console.error("Error sending your reply:", error);
        } finally {
            setIsSending(false);
        }
    }, [reportId, userReplyText, userReplyImage, fetchReport]);

    const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleUserReplySubmit();
        }
    }, [handleUserReplySubmit]);


    if (isLoadingInitial) {
        return <div className="flex justify-center items-center h-screen">Loading...</div>;
    }

    if (!report) {
        return null;
    }

    return (
        <div className="chat-container">
            <div className="chat-header">
                <h3 className="chat-title">{report.category || "No Category"}</h3>
                <button onClick={() => navigate('/report')} className="chat-close-button">
                    <MdClose className="chat-close-icon" />
                </button>
            </div>
            <div ref={chatHistoryRef} className="chat-history">
                {report.autoReply && (
                    <div className="message received">
                        <div className="message-content">
                            <p className="message-text">{report.autoReply}</p>
                            <p className="message-sender">Moderator</p>
                        </div>
                        <p className="message-time">{format(new Date(), "yyyy-MM-dd")}</p>
                    </div>
                )}
                {report.chatHistory && report.chatHistory.map((msg, index) => (
                    <div
                        key={index}
                        className={`message ${msg.sender === "admin" ? "sent" : "received"}`}
                    >
                        <div className="message-content">
                            <p className="message-text">{msg.message}</p>
                            {/* <p className="message-sender">{msg.sender === "admin" ? "Moderator" : user?.name}</p> */}
                        </div>
                        {msg.image && (
                            <img src={msg.image} alt="Chat Attachment" className="message-image" />
                        )}
                        <p className="message-time">{format(new Date(msg.createdAt), "HH:mm")}</p>
                    </div>
                ))}
            </div>
            <div className="chat-input-area">
                {userReplyImage && (
                    <div className="reply-image-preview">
                        <img src={userReplyImage} alt="Your Reply" className="preview-image" />
                        <button className="remove-image-button" onClick={handleRemoveUserReplyImage}>
                            <MdClose />
                        </button>
                    </div>
                )}
                <div className="chat-input-box">
                    <textarea
                        className="chat-input"
                        placeholder="Type your reply..."
                        value={userReplyText}
                        onChange={handleUserReplyTextChange}
                        onKeyDown={handleKeyDown}
                    />
                    <div className="chat-input-actions">
                        <label className="attach-image-button">
                            <input type="file" className="hidden" onChange={handleUserReplyImageUpload} />
                            <MdAdd className="attach-icon" />
                        </label>
                        <button
                            className="send-button"
                            onClick={handleUserReplySubmit}
                            disabled={isSending || uploadingReplyImage || (!userReplyText && !userReplyImage)}
                        >
                            <MdSend className="send-icon" />
                        </button>
                    </div>
                </div>
                {uploadingReplyImage && <p className="uploading-text">Uploading image...</p>}
            </div>
        </div>
    );
};

export default ReportCard;